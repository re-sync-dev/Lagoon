"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[108],{5753:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"network-trait","title":"Using the Network Trait","description":"What is it for?","source":"@site/docs/network-trait.md","sourceDirName":".","slug":"/network-trait","permalink":"/Lagoon/docs/network-trait","draft":false,"unlisted":false,"editUrl":"https://github.com/re-sync-dev/Lagoon/edit/main/docs/network-trait.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"defaultSidebar","previous":{"title":"Using the Logger Trait","permalink":"/Lagoon/docs/logger-trait"},"next":{"title":"Known Problems","permalink":"/Lagoon/docs/bugs"}}');var o=t(74848),a=t(28453);const i={sidebar_position:4},s="Using the Network Trait",c={},l=[{value:"What is it for?",id:"what-is-it-for",level:2},{value:"Creating a Remote",id:"creating-a-remote",level:2},{value:"Connections &amp; Bindings",id:"connections--bindings",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"using-the-network-trait",children:"Using the Network Trait"})}),"\n",(0,o.jsx)(n.h2,{id:"what-is-it-for",children:"What is it for?"}),"\n",(0,o.jsx)(n.p,{children:"The network trait is used to simplify networking on the client and server by creating a straight forward API"}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-remote",children:"Creating a Remote"}),"\n",(0,o.jsxs)(n.p,{children:["Pretty straight forward you just take the suffix of the instance for example the 'Event' part of RemoteEvent or the 'Function' part of ",(0,o.jsx)(n.a,{href:"https://create.roblox.com/docs/reference/engine/classes/RemoteFunction",children:"RemoteFunction"})," and put 'Create' infront of it."]}),"\n",(0,o.jsx)(n.p,{children:"Example of remote creation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'Network:CreateEvent("MyRemoteEvent") --\x3e RemoteEvent\nNetwork:CreateFunction("MyRemoteFunction") --\x3e RemoteFunction\n'})}),"\n",(0,o.jsx)(n.p,{children:"We can also create unreliable remote events utiling the same method:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'Network:CreateEvent("MyUnreliableRemoteEvent", true) --\x3e UnreliableRemoteEvent\n'})}),"\n",(0,o.jsx)(n.h2,{id:"connections--bindings",children:"Connections & Bindings"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Connections"})," simply put is the association between a given RemoteEvent/Signal and a function that can occur many times. This association in the context of normal Roblox signals is called an ",(0,o.jsx)(n.a,{href:"https://create.roblox.com/docs/reference/engine/datatypes/RBXScriptConnection",children:"RBXScriptConnection"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Using this information we can call the ",(0,o.jsx)(n.code,{children:":Connect"})," method to associate a callback with an Event like so:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Server.luau:\nNetwork:Connect("Say", function(Player: Player, Message: string)\n\tprint(`{Player.Name} said: \'{Message}\'`)\nend)\n\n-- Client.luau:\nNetwork:Fire("Hello, world!")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Not only can you associate the callback to the Event but you can also dissociate them using the return connection's ",(0,o.jsx)(n.code,{children:":Disconnect"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'local Connection = Network:Connect("Say", function(Player: Player, Message: string)\n\tprint(`{Player.Name} said: {Message}`)\nend)\n\ntask.wait(3)\n\nConnection:Disconnect() --\x3e Removes the association\nConnection = nil --\x3e Dereference the dead connection so it can be garbage collected\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Bindings"})," on the other hand are a bit different, there can only ever be one callback associated with the ",(0,o.jsx)(n.a,{href:"https://create.roblox.com/docs/reference/engine/classes/RemoteFunction",children:"RemoteFunction"}),". While the work similarly there are some key differences between the two, for example instead of returning an ",(0,o.jsx)(n.a,{href:"https://create.roblox.com/docs/reference/engine/datatypes/RBXScriptConnection",children:"RBXScriptConnection"})," ",(0,o.jsx)(n.code,{children:":Bind"})," returns a function that unbinds the callback when called."]}),"\n",(0,o.jsx)(n.p,{children:"Let's try creating a binding that returns a boolean true if the player was able to start the trade and false if the trade could not be started:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-lua",children:'-- Server.luau:\nNetwork:Bind("Trade", function(Player: Player, OtherPlayer: Player)\n\t-- Is the caller in a trade:\n\tif Player:GetAttribute("InTrade") then\n\t\treturn false\n\tend\n\n\t-- Is the other player in a trade:\n\tif OtherPlayer:GetAttribute("InTrade") then\n\t\treturn false\n\tend\n\n\t-- Do something to start the trade\n\n\treturn true\nend)\n\n-- Client.luau:\nNetwork:Invoke("Trade", Players.VyonEXE) --\x3e That\'s me :D\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(96540);const o={},a=r.createContext(o);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);